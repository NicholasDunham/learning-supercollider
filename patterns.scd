// Classes beginning with a capital P are various types of patterns. Patterns
// are a concise way of describing calculations declaratively, rather than
// procedurally. They're ideal for specifying sequences, or streams, of
// information.

// For example, you can use `Pseries` to specify an infinite series of integers
// starting with 0:

a = Pseries(start: 0, step: 1, length: inf).asStream;

a.nextN(10); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]

// The same pattern could also be represented as a Routine:

(
a = Routine.new({
  (0..).do { |i|
    i.yield;
  };
});
)

a.nextN(10);

// But the pattern is more concise, easier to understand, and has been tested
// by others, so it requires less debugging.

// It's also important to understand the difference between a pattern and a
// stream.  Patterns define behavior, whereas streams execute it. This is why
// we had to call `asStream` on the `Pseries` above before we could get any
// integers from it: the pattern has no concept of internal state; it's just a
// blueprint for a sequence. This is also the reason why when we call the
// `play` method on a pattern we need to assign it to a variable: `play`
// returns an `EventStreamPlayer`, which has internal state and thus can be
// stopped, muted, reset, and otherwise manipulated later.

// A `Routine` is a subclass of `Stream`, and when we send the `asStream`
// message to a `Pattern` we also generate a stream. But it's important to
// recognize the difference between a pattern and a stream. A pattern can be
// thought of as a blueprint for a sequence of values. A stream is the
// state-oriented execution of that sequence. This is the same paradigm as a
// class and an instance, or a `SynthDef` and a `Synth`: a recipe for a thing,
// and the stateful execution of that recipe.

// Patterns can be nested.

p = Pseq([1, 2, 3, Prand([100, 200, 300], 1)], inf).asStream;
p.nextN(20);

// And you can do mathematical operations on patterns.

p = (Pseq([1, 2, 3], inf) * Pseq([100, 200], inf)).asStream;
p.nextN(20);

// `Pbind` is possibly the most commonly-used pattern in SuperCollider because
// it's so well-tuned for creating sound. Rather than creating a stream of
// numbers, `Pbind` creates a stream of objects in the `Event` class.

// An `Event` is a type of collection.

e = Event.new;

e.add(\foo -> 5);
e.add(\bar -> 12);

e.at(\foo);

// Alternate syntaxes are available.

e = ( foo: 5, bar: 12 );
e[\foo];
e.bar;

// Events can be used to model objects.

~sandwich = ();
~sandwich.add(\bread -> "wheat");
~sandwich.add(\toasted -> true);
~sandwich.add(\mayo -> false);

~sandwich.mayo;

// Events are expected to have a `play` key, the value of which is a function
// to be run when you evaluate the `play` key.

~whoami = (name: "Nicholas", play: {("My name is " ++ \name.envirGet).postln});
~whoami.play;

// Interestingly, if you don't give an event a `play` key, one is automatically
// generated by default.

~sandwich.play;

// `Pbind` is a pattern that generates events. (An event is a collection of
// key-value pairs, and `Pbind` binds values to keys.)

(
p = Pbind(
  \freq, Pseq([300, 500, 700], inf),
  \amp, Prand([0.1, 0.2], inf),
);
)

p.play;

